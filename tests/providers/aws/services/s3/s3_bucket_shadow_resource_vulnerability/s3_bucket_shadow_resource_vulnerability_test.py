from unittest import mock

from moto import mock_aws

from prowler.providers.aws.services.s3.s3_service import Bucket
from tests.providers.aws.utils import (
    AWS_ACCOUNT_NUMBER,
    AWS_REGION_US_EAST_1,
    set_mocked_aws_provider,
)


class Test_s3_bucket_shadow_resource_vulnerability:
    @mock_aws
    def test_no_buckets(self):
        s3_client = mock.MagicMock
        s3_client.buckets = {}
        aws_provider = set_mocked_aws_provider([AWS_REGION_US_EAST_1])
        aws_provider.identity.identity_arn = f"arn:aws:iam::{AWS_ACCOUNT_NUMBER}:root"
        s3_client = mock.MagicMock
        s3_client.provider = aws_provider
        with mock.patch(
            "prowler.providers.common.provider.Provider.get_global_provider",
            return_value=aws_provider,
        ), mock.patch(
            "prowler.providers.aws.services.s3.s3_bucket_shadow_resource_vulnerability.s3_bucket__resource_vulnerability.s3_client",
            new=s3_client,
        ):
            from prowler.providers.aws.services.s3.s3_bucket_shadow_resource_vulnerability.s3_bucket_shadow_resource_vulnerability import (
                s3_bucket_shadow_resource_vulnerability,
            )

            check = s3_bucket_shadow_resource_vulnerability()
            result = check.execute()
            assert len(result) == 0

    @mock_aws
    def test_bucket_owned_by_account(self):
        s3_client = mock.MagicMock
        bucket_name = f"sagemaker-{AWS_REGION_US_EAST_1}-{AWS_ACCOUNT_NUMBER}"
        s3_client.audited_account_id = AWS_ACCOUNT_NUMBER
        s3_client.audited_identity_arn = f"arn:aws:iam::{AWS_ACCOUNT_NUMBER}:root"
        s3_client.buckets = {
            bucket_name: Bucket(
                name=bucket_name,
                arn=f"arn:aws:s3:::{bucket_name}",
                region=AWS_REGION_US_EAST_1,
                owner_id=AWS_ACCOUNT_NUMBER,
            )
        }
        aws_provider = set_mocked_aws_provider([AWS_REGION_US_EAST_1])
        aws_provider.identity.identity_arn = f"arn:aws:iam::{AWS_ACCOUNT_NUMBER}:root"
        s3_client = mock.MagicMock
        s3_client.provider = aws_provider
        with mock.patch(
            "prowler.providers.common.provider.Provider.get_global_provider",
            return_value=aws_provider,
        ), mock.patch(
            "prowler.providers.aws.services.s3.s3_bucket_shadow_resource_vulnerability.s3_bucket_shadow_resource_vulnerability.s3_client",
            new=s3_client,
        ):
            from prowler.providers.aws.services.s3.s3_bucket_shadow_resource_vulnerability.s3_bucket_shadow_resource_vulnerability import (
                s3_bucket_shadow_resource_vulnerability,
            )

            check = s3_bucket_shadow_resource_vulnerability()
            result = check.execute()
            assert len(result) == 1
            assert result[0].status == "PASS"
            assert "is correctly owned by the audited account" in result[0].status_extended

    @mock_aws
    def test_bucket_owned_by_another_account(self):
        s3_client = mock.MagicMock
        bucket_name = f"aws-glue-assets-{AWS_ACCOUNT_NUMBER}-{AWS_REGION_US_EAST_1}"
        s3_client.audited_account_id = AWS_ACCOUNT_NUMBER
        s3_client.audited_identity_arn = f"arn:aws:iam::{AWS_ACCOUNT_NUMBER}:root"
        s3_client.buckets = {
            bucket_name: Bucket(
                name=bucket_name,
                arn=f"arn:aws:s3:::{bucket_name}",
                region=AWS_REGION_US_EAST_1,
                owner_id="ANOTHER_ACCOUNT_ID",
            )
        }
        aws_provider = set_mocked_aws_provider([AWS_REGION_US_EAST_1])
        aws_provider.identity.identity_arn = f"arn:aws:iam::{AWS_ACCOUNT_NUMBER}:root"
        s3_client = mock.MagicMock
        s3_client.provider = aws_provider
        with mock.patch(
            "prowler.providers.common.provider.Provider.get_global_provider",
            return_value=aws_provider,
        ), mock.patch(
            "prowler.providers.aws.services.s3.s3_bucket_shadow_resource_vulnerability.s3_bucket_shadow_resource_vulnerability.s3_client",
            new=s3_client,
        ):
            from prowler.providers.aws.services.s3.s3_bucket_shadow_resource_vulnerability.s3_bucket_shadow_resource_vulnerability import (
                s3_bucket_shadow_resource_vulnerability,
            )

            check = s3_bucket_shadow_resource_vulnerability()
            result = check.execute()
            assert len(result) == 1
            assert result[0].status == "FAIL"
            assert "is owned by another account" in result[0].status_extended

    @mock_aws
    def test_bucket_not_predictable(self):
        s3_client = mock.MagicMock
        bucket_name = "my-non-predictable-bucket"
        s3_client.audited_account_id = AWS_ACCOUNT_NUMBER
        s3_client.audited_identity_arn = f"arn:aws:iam::{AWS_ACCOUNT_NUMBER}:root"
        s3_client.buckets = {
            bucket_name: Bucket(
                name=bucket_name,
                arn=f"arn:aws:s3:::{bucket_name}",
                region=AWS_REGION_US_EAST_1,
                owner_id=AWS_ACCOUNT_NUMBER,
            )
        }
        aws_provider = set_mocked_aws_provider([AWS_REGION_US_EAST_1])
        aws_provider.identity.identity_arn = f"arn:aws:iam::{AWS_ACCOUNT_NUMBER}:root"
        s3_client = mock.MagicMock
        s3_client.provider = aws_provider
        with mock.patch(
            "prowler.providers.common.provider.Provider.get_global_provider",
            return_value=aws_provider,
        ), mock.patch(
            "prowler.providers.aws.services.s3.s3_bucket_shadow_resource_vulnerability.s3_bucket_shadow_resource_vulnerability.s3_client",
            new=s3_client,
        ):
            from prowler.providers.aws.services.s3.s3_bucket_shadow_resource_vulnerability.s3_bucket_shadow_resource_vulnerability import (
                s3_bucket_shadow_resource_vulnerability,
            )

            check = s3_bucket_shadow_resource_vulnerability()
            result = check.execute()
            assert len(result) == 1
            assert result[0].status == "PASS"
            assert "is not a known shadow resource" in result[0].status_extended
